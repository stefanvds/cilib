{"docs":[{"location":"/index.html","text":"","title":"Cilib"},{"location":"/index.html#cilib","text":"CIlib is a library of computational intelligence algorithms. The goal is to provide a library that can be used by researchers and invididuals, which provides sound implementations that adhere to very principled design, and verification.\nSome of the core requirements for the library are:\nProvide implmentations that are type safe, functional and focused on composition. Allow for the exact reproduction of experiments and simulations, allowing researchers to validate and reuse prior work with confidence\nCIlib is not a framework - instead the library is founded on some very simple abstractions, from which the algorithm parts are constructed.","title":"Cilib"},{"location":"/index.html#resources","text":"Come join in the discussion in #cilib on FreeNode, or join the Gitter channel scaladoc The source code of the project also contains several examples, have a look in the example directory If you run into trouble, please open an issue\nCIlib is maintained by several individuals and supported by CIRG @ UP (Computational Intelligence Research Group @ University of Pretoria).","title":"Resources"},{"location":"/design/index.html","text":"","title":"Design"},{"location":"/design/index.html#design","text":"CIlib is software library which aids in the experimentation and research of Computational Intelligence algorithms. Previously, in version 1.0 and lower, CIlib started demonstrating several shortcomings, and as a result, the current development process began. In order to address these shortcomings, the following goals were highlighted:","title":"Design"},{"location":"/design/index.html#principled-design","text":"It is very important to ensure that the library code is pure - thereby reducing complexity. This has many advantages but, most importantly, it allows for the controlling of side-effects which is a primary concern, especially when randomness is involved. As a consequence of this, and other aspects, CIlib makes an active effort to address the following:\nCorrectness: All algorithmic components should be correct and operate as intended, doing nothing more. Peer-review is hugely valuable in this regard, providing the confidence that the implementations are correct and sound. Type safety: The use of types is a fantastic way to ensure that a program cannot represent invalid states. This removes a huge set of potential errors and ensures greater confidence, as the compiler is always double-checking the code. Reproducability: Within scientific research, being able to reproduce the work of another researcher is important. It’s also a fundamental part of the scientific method. With complexities such as randomness, this becomes much more difficult and is generally extremely cumbersome. CIlib must allow for the perfect replication of experimental work.","title":"Principled design"},{"location":"/design/index.html#project-structure","text":"Trying to maintain a modular set of functionalities, CIlib consists of several sub-projects:\ncore - contains typeclass definitions together with required data structures exec - simplistic execution code allowing for experimental execution de - data structures and logic related to Differential Evolution docs - sources for the website ga - data structures and logic related to Genetic Algorithms moo - typeclasses, instances and data structures for Multi-Objective Optimization pso - data structures and logic related to Particle Swarm Optimization","title":"Project structure"},{"location":"/design/index.html#support","text":"If you have any feedback or questions, please contact is in #cilib on FreeNode IRC or come chat to us in the project’s Gitter channel; alternatively, feel free to open an issue.","title":"Support"},{"location":"/design/overview.html","text":"","title":"Overview"},{"location":"/design/overview.html#overview","text":"This section details the design of CIlib. The intention is that this part of the documentation should be enough to allow you to fully understand the reasoning behind some design decisions as well as giving the needed knowledge to allow extensions to be made that use the core data structures in CIlib.\nThe core of CIlib itself is divided into a few data structures. These structures control the effects of randomness within an algorithm, the manner in which the optimization scheme is used (minimization or maximization) and defines the way in which small pieces of logic may be composed into larger pieces for inclusion in an algorithm definition.\nThe manner in which such effects are controlled, is managed by structures provided to us by the world of mathematics and these general structures, may, seem to have odd names. We assure you that these names only sound odd due to the fact that they are unfamiliar to you. As they become familiar you will not only see the benefits that they provide, but also that they provide a common nomenclature, which is very handy! It allows us to talk about various aspects of an algorithm without having to worry about the manner in which such an action may be performed. It is, however, true that we do need to worry about the execution semantics at some point so that the algorithm is executed correctly.\nThe sections that follow will explain different aspects of CIlib, which is a progression of different types to build up the needed structures.\nFor all usage samples, the following imports are required within the REPL session, but will be ignored to favor discussion:\nimport scalaz._\nimport Scalaz._\n\nimport cilib._","title":"Overview"},{"location":"/design/lenses.html","text":"","title":"Immutable data"},{"location":"/design/lenses.html#immutable-data","text":"Immutable data is fantastic because it allows anyone to read the contents of the data and provides the security that the data will not change. In some cases, however, we would like to “change” some data value. Using immutable data means that we cannot change the value within a structure, instead we need to create an updated view of the data with the changes applied. This updated view creates new data, where the old data is still present and unchanged. It’s recommended that the reader become familiar with persistent data structures and how they operate. Due to how persistent data structures update, by only changing the smallest number of references, the needed speed and efficiency is achieved.\nScala tries to help with respect to immutable data, by providing a convenience method on all case classes called copy. In situations where there is a nesting of case classes, potentially several levels, the updating of a value on the lower levels results in a bubbling-up process whereby each previous layer needs to update the reference to the new data in the lower layer. Although this is not difficult to do, the result is very verbose and extremely cumbersome for the user. It would be nice if this “zooming” update process was abstracted behind a data structure that would hide and automate the tedious process.","title":"Immutable data"},{"location":"/design/lenses.html#lenses","text":"A Lens can, in the most trivial of ways, be seen as a simple getter and setter function pair. Within CIlib, several common lenses are available in order to extract information from the state of the Entity, or anything else for which a Lens has been defined. Because lenses allow the user to “zoom” onto data, potentially nested under many levels in another data structure, they are convenient as they allow for correctly updating the “zoomed” location in addition to extracting the value.\nTrying to not re-invent the wheel, the [Monocle](http://julien-truffaut.github.io/Monocle/) library provides the lens functionality. Lenses are structures that can also be composed together and are collectively called “optics”. Please refer to Monocle’s documentation to learn more about lenses and optics. CIlib specific lens questions can be directed to the CIlib gitter room or IRC.\nLenses provide an API that is first and foremost, composition and lawful. This means that the various optics are well behaved and rules exist that govern their usage. Furthermore, different optics may be composed together to create new optics that are the combination of the original optics. This is obviously only possible if the provided types correctly line up.\nBuilding on the usage of optics in general, we use a mechanism known as “classy lens” in Haskell. This mechanism prevents invalid usage, by letting the compiler fail based on the types being used. In the case of Entity, the compiler would look up instances, using it’s implicit resolution rules, to obtain evidence for a typeclass with a given set of types, at compile time.\nThis provides an additional level of surety, that the data being passed to a function that requires evidence in order to extract some other piece of information for a given type. The scala compiler provides the evidence through the use of its implicit lookup mechanics. This may seem quite like a mouthful, but let’s have a look a few examples that will hopefully make the usage clearer.\nBased on the normally accepted usage of “classy lenses”, the typeclasses that expose the lenses are generally prefixed with Has. An example of this would be the HasMemory typeclass. The typeclass definition is simply:\ntrait HasMemory[S,A] {\n  def _memory: Lens[S, Position[A]]\n}\nHasMemory defines a lens member, with the name _memory that can from a given S provide a Position[A]. There is absolutely no mention of what S is, or should be, but the typeclass allows for a set of instances that can actually provide this result. Within the context of the GA, Individuals are entities that do not maintain a memory; whereas within the PSO, Particles do maintain a memory of their previous best position (where Position[A] is a candidate solution of the problem space). The base module within the library already provides several optics for the user that operate on Position[A] instances, allowing for the extraction of the candidate solution, the fitness and the constraint violations. Other optics for other structures are also available.\nThe usage of these classy lenses will become even clearer when we look into what the generalization of Individual and Particle, the Entity.","title":"Lenses"},{"location":"/design/position.html","text":"","title":"Position"},{"location":"/design/position.html#position","text":"Candidate solution vectors within a search space are the basic pieces of information that computational algorithms maintain and, includes feature vectors that represent training patterns in a neural network. Within population based algorithms, a collection of algorithm participants are employed in a search of the problem space. Each represents a possible solution to the problem at hand, and may be in one of two possible states:\nIt may be a “point” in the search space where no other information about the point is known, except for the value of the multi-dimensional vector representing the position within the search space It may be a possible “solution”, where the position in the multi-dimensional search space is known but, an additional value representing the “quality” of the vector is also maintained. This “quality” is referred to as the fitness of the candidate solution.\nPosition is a data structure that encodes the above two cases exactly, allowing a Position to either be a Point or a Solution. Further more, Position is an Algebraic Data Type (ADT), whereby the set of possible representations may not be extended further (and is enforced by the compiler). Any changes to a Solution will yield a Point - the new Position has not yet had a fitness calculated, i.e: the quality of the Position is an unknown.\nA Position, within a search space, can be created by providing the search space bounds to the createPosition function. The search space must have at least a single dimension (the zero-dimensional search is trivial) and, a NonEmptyList[Interval[Double]] represents the search space bounds. A NonEmptyList is a list that is guaranteed to have at least one contained element.\nA search space is determined by a list of Interval instances (provided by spire), one for each dimension. The Interval need not be the same for each dimension and differing Intervals may be placed together in a NonEmptyList to define the problem search space. As it is rather common to define a search space where an interval repeats n times, some syntax has been added to the Interval data constructor to allow for repetition in a more convenient way. This syntax models the text parser used in CIlib 1.0 for the “domain string”, but is now available at the type level and verifiable during compilation. As an example, let’s create a 30-dimensional vector in the interval $[-5.12, 5.12]$:\nInterval(-5.12,5.12)^30\nA Position may now be constructed, as we know what the bounds of the search space are\nPosition.createPosition(Interval(-5.12,5.12)^30)\nThe result of creating a Position is a RVar[Position[A]] computation, as the Position is created with a vector placed randomly within the search space bounds. Furthermore, the type of the dimension elements within the Position is inferred, based on the provided Interval information (in this example a Double).\nThe normal vector operations are provided, as syntax, to make the usage simpler and to mirror the mathematics defined in literature more closely. Below are some examples of combining Position instances. Take careful note of the return value for the different cases of Position. In order to evaluate the quality of a Position an Eval instance is required.\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x*x).suml)\n\nval (_, (a, b)) = // a is a Point and b is a Solution\n  (for {\n    a <- Position.createPosition(Interval(-5.12,5.12)^3)\n    b <- Position.createPosition(Interval(-5.12,5.12)^3).flatMap(p => Position.eval(e, p))\n  } yield (a, b)).run(RNG.init(1234L))\n\n-a // Unary syntax to negate a Position\n\na + b // Add Point and Solution\n\na + a // Add Point and Point\n\nb + b // Add Solution and Solution\n\na - b // Subtract Solution from Point\n\n// a * b does not compile. Vector multiplication makes little sense.\n// If the objective was to use pairwise multiplication, there is another\n// structure called `Pointwise` which can be used to achieve this operation\n// via the `Algebra` object.\nAlgebra.pointwise(a, b)\n\n3.0 *: a // Scalar multiplication\nWhenever a Position is moved to a “new point” within the search space, it requires re-evaluation.","title":"Position"},{"location":"/design/entity.html","text":"","title":"Entity"},{"location":"/design/entity.html#entity","text":"Within swarm intelligence, evolutionary computation and other, similar algorithms, there is always a metaphor that the algorithm is based on. Using this metaphor, the participants within the algorithm are also appropriately named. For example, within a Particle Swarm Optimization (PSO), the participants are referred to as Particles, with Individuals being used in both Differential Evolution (DE) and Genetic Algorithms (GA). Many other examples can easily be identified in available literature.\nIt is not practical to have several representations for a very similar concept used within these algorithms. Based on experimentation within CIlib, a common structure was identified that could be used to represent the participants for these metaphor-based population based algorithms. We refer, collectively, to these algorithm participants as Entity instances.\nAn Entity is a simple structure that contains and manages two very specific things:\nA Position[A] within the current search space of the problem A “state” that contains all addition data required by the Entity which is not managed by the Position[A].\nThe resulting Entity is therefore represented by the following parameterized data type:\nfinal case class Entity[S,A](state: S, pos: Position[A])\nwhere S is the type of the state that the Entity maintains, and A is the type of the dimension element within a Position[A].\nThe state value differs between Entity instances. A Particle requires a velocity vector and a previous best position vector, whilst an Individual, requires no additional data other that a Position.\nBecause the value of S within the Entity can be anything, it is not possible to have predefined functions that allow extraction of data the S parameter type. In order to enable this, optics are applied to the instances.\nWithin the definitions of CIlib, an Individual is nothing more than an Entity[Unit,A] for some type A. As the type states, there is no state value for the Entity, and it is defined to be Unit - a type that exists with a single value (expressed as ()), which is uninteresting.\nSome functions use Entity instances, but constrain the usage based on the shape of the S type parameter within the Entity[S,A]. As mentioned within the discussion of lenses and optics, a typeclass HasMemory is defined to allow a state to contain information about some kind of memory for an Entity. A data structure that provides this memory for a Particle is Mem[A], and is simply the case class:\ncase class Mem[A](b: Position[A], v: Position[A])\nThere already exists an instance of HasMemory defined for the Mem data structure. Let’s have a look at some usage:\nscala> // Lets create a function that expects the provided Entity to have\n     | // a memory within it's state parameter\n     | def foo[S](x: Entity[S,Double])(implicit mem: HasMemory[S,Double]) =\n     |   mem._memory.get(x.state)\nfoo: [S](x: cilib.Entity[S,Double])(implicit mem: cilib.HasMemory[S,Double])cilib.Position[Double]\n\nscala> // Now, lets create some Entity instances\n     | val interval = Interval(-5.12,5.12)^3\ninterval: scalaz.NonEmptyList[spire.math.Interval[Double]] = NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n\nscala> val individual = Position.createPosition(interval).map(p => Entity((), p))\nindividual: cilib.RVar[cilib.Entity[Unit,Double]] = cilib.RVar$$anon$2@62b1122d\n\nscala> val particle = Position.createPosition(interval).map(p => Entity(Mem(p, p.zeroed), p))\nparticle: cilib.RVar[cilib.Entity[cilib.Mem[Double],Double]] = cilib.RVar$$anon$2@56abf762\nTake note of the value held by the state parameter in the resulting entity instances above. We would need to run the RVar computation to get the individual and particle values, or we can simply map the function foo into the RVar, changing the result of the computation to a RVar which when executed will return the memory of the Entity.\nscala> particle.map(p => foo(p)) // This works as expected: particles have a memory\nres3: cilib.RVar[cilib.Position[Double]] = cilib.RVar$$anon$2@78da83d2\nBecause individual does not have a memory defined, the following will fail. This failure is not only expected but required to ensure that incorrect usages are disallowed as soon as possible.\nscala> individual.map(i => foo(i))\n<console>:24: error: A HasMemory instance cannot be found for the provided state type Unit\n       individual.map(i => foo(i))\n                              ^\nThere are several optics predefined that allow for the zooming in of values in the Position as well as the state of an Entity. Of course a user could define their own optics, and it is recommended when custom state types are used, in order to work with the Entity data.","title":"Entity"},{"location":"/design/rvar.html","text":"","title":"RVar"},{"location":"/design/rvar.html#rvar","text":"An instance of RVar represents a computation that, when executed, results in a value with randomness applied. RVar is one of the most important structures in CIlib and is therefore discussed first in order to understand how the data structure works.\nRVar has a monad instance and therefore allows a for a large amount of composition, but more importantly allows for the tracking of randomness within the RVar computation. This tracking is of the utmost importance within computational intelligence algorithms, as randomness needs to be controlled in a manner that facilitates repetition. In other words, even if a computation uses randomness, given the same inputs, the same results are expected even with randomness applied.\nDue to the monadic nature of the data structure, the data structure may be transformed by functions such as map, flatMap, etc\nThere are several predefined combinators that allow the user to use and create RVar computations. These include functions for randomness applied to primitive types (such and Int and Double) to more complex types that build on the primitives, or even for user defined types.\nThe simplest would be to look at some examples of RVar usage. It is quite common to request several random numbers. RVar provides several functions, with ints and doubles being the most common for random variable creation:\nscala> val ints = RVar.ints(5)\nints: cilib.RVar[List[Int]] = cilib.RVar$$anon$2@2c316b30\n\nscala> val doubles = RVar.doubles(5)\ndoubles: cilib.RVar[List[Double]] = cilib.RVar$$anon$2@682d80ee\nBoth functions result in a RVar that, when provided with a pseudo-random number generator (PRNG), will result in a list of values.\nThe user if free to define a PRNG for themselves, but CIlib provides a default PRNG that is suitable for scientific work. The CMWC generator may be initialized by either providing a seed value for the pseudo-random number stream, or it may be taken from the current time of the computer. It is always recommended to record the seed value, so that others may reproduce results, especially if the results are to be published.\nLet’s create a RNG instance using both methods:\nscala> val rng = RNG.init(1234L)\nrng: cilib.RNG = cilib.CMWC@7527c291\n\nscala> val fromTimeYOLO = RNG.fromTime\nfromTimeYOLO: cilib.RNG = cilib.CMWC@51ae5297\nNow, let’s run both doubles and ints with the generator:\nscala> val r1 = ints.run(rng)\nr1: (cilib.RNG, List[Int]) = (cilib.CMWC@30db9bbe,List(-2012280037, -456312394, -1608573853, -1720473833, 1662253751))\n\nscala> doubles.run(rng)\nres0: (cilib.RNG, List[Double]) = (cilib.CMWC@701bb24,List(0.5314795508050395, 0.6254747152242208, 0.3870236094802634, 0.3590652564475848, 0.1350043437170152))\n\nscala> val r2 = ints.run(rng)\nr2: (cilib.RNG, List[Int]) = (cilib.CMWC@ee96008,List(-2012280037, -456312394, -1608573853, -1720473833, 1662253751))\n\nscala> r1._2 == r2._2\nres1: Boolean = true\nThe result is a tuple of the state of the PRNG after being used in the computation, together with the result of the computation itself. The important point to note is that running the computation again, with the same PRNG, that is the original state of the PRNG will result in the same obtained results. Unlike the normal PRNG within the JVM platform, obtaining some random value from the source does not implicitly mutate the PRNG. In order to keep selecting from the PRNG stream, the next state of the PRNG should be passed into subsequent computations, when needed:\nscala> val (rng2, x) = ints.run(rng)\nrng2: cilib.RNG = cilib.CMWC@2691964b\nx: List[Int] = List(-2012280037, -456312394, -1608573853, -1720473833, 1662253751)\n\nscala> val (rng3, y) = ints.run(rng2)\nrng3: cilib.RNG = cilib.CMWC@79901456\ny: List[Int] = List(-973239118, 1542173555, 1984558752, 579839250, 609517835)\n\nscala> x != y\nres2: Boolean = true\nThis manual state passing for the PRNG is very cumbersome and as a result, the monad instance of RVar provides this exact functionality to the user, thereby preventing accidental errors due to incorrect usage of PRNG state. Furthermore, the monad instance for RVar allows for cleaner syntax through the use of a for-comprehension as provided by Scala:\nscala> val composition = for {\n     |   a <- RVar.next[Int] // Get a single Int\n     |   b <- RVar.next[Double] // Get a single Double, using the next state of the PRNG\n     |   c <- RVar.next[Boolean] // Get a Boolean, again passing the PRNG state\n     | } yield if (c) a*b else b\ncomposition: cilib.RVar[Double] = cilib.RVar$$anon$2@1cfd69d7\n\nscala> composition.run(rng)\nres3: (cilib.RNG, Double) = (cilib.CMWC@5ded4bc8,-1.798488339436242E9)\nFrom this definition of how randomness is managed, we can derive several useful algorithms which operate within the RVar computation. Please refer to the scaladoc for more combinators, but some of the more commonly used are illustrated below:\nscala> val sampleList = NonEmptyList(6,4,5,2,1,3)\nsampleList: scalaz.NonEmptyList[Int] = NonEmpty[6,4,5,2,1,3]\n\nscala> RVar.shuffle(sampleList).run(rng)\nres4: (cilib.RNG, scalaz.NonEmptyList[Int]) = (cilib.CMWC@7a043c1,NonEmpty[4,3,5,1,2,6])\n\nscala> RVar.sample(3, sampleList).run.run(rng)\nres5: (cilib.RNG, Option[List[Int]]) = (cilib.CMWC@50dc83ee,Some(List(5, 3, 4)))\nBuilding on RVar, we can easily define probability distributions from which, randomness may be sampled. The provided distributions, where standard distributions are also defined, include:\nUniform Gaussian / Normal Cauchy Gamma Exponential etc\nThe interface for the distributions is simply a resulting RVar\nscala> // Use a derived function from monad to repeat an action 'n' times\n     | Dist.stdNormal.replicateM(5).run(rng)\nres7: (cilib.RNG, List[Double]) = (cilib.CMWC@42dae6c0,List(0.12471034611540575, 0.10241216207344515, -0.49485286860096944, -2.6592051237450325, 0.7016898748604742))","title":"RVar"},{"location":"/design/step.html","text":"","title":"Step"},{"location":"/design/step.html#step","text":"Apart from tracking the effect of randomness, a computational intelligence algorithm requires some additional information:\nThe optimization scheme (Opt) required, either minimization or maximization The fitness function evaluation instance, Eval, which calculates the quality of the candidate solution\nThe result is a function, which uses a predefined set of values to generate a RVar computation to which randomness still needs to be applied. The function is therefore of the shape\n(Opt,Eval[A]) => RVar[B]\nThe predefined set of values required for input is also referred to as the “environment”. Given that the environment is decided once, at the beginning of the execution process, we can factor out this common parameter using a Kleisli arrow, on this case the ReaderT monad transformer is applicable, resulting in the final type of:\nReaderT[RVar, (Opt,Eval[A]), B]\nBecause monad transformers are monads themselves, we can freely compose different Step instances to create a larger computation. The larger computation, being termed the “algorithm”. Due to the sequencing action of monads, Step instances are analogous to steps in algorithm pseudo-code.\nNow that the intention of Step is clearer, lets have a look at some usage. Keep in mind that even though the final “shape” of the Step is defined, this does not limit the manner in which we can create Step instances. Within a PSO, each particle has several actions applied to it, in order to create a new particle that occupies a different location within the problem search space.\nThe canonical PSO algorithm iteratively alters the position (and state data) of each particle to create a new particle for each within the collection. The new collection essentially replaces the original collection and this process repeats until some kind of stopping condition is met. Stopping condition logic is intentionally not included within the Step. The type for a PSO is then\nList[Particle[S,A]] => Particle[S,A] => Step[RVar,(Opt,Eval[A]),Particle[A]]\nand the algorithm definition is:\nscala> def pso[S](w: Double, c1: Double, c2: Double,\n     |   cognitive: Guide[S,Double], social: Guide[S,Double]\n     | )(implicit M: HasMemory[S,Double], V: HasVelocity[S,Double]\n     | ): NonEmptyList[Particle[S,Double]] => Particle[S,Double] => Step[Double,Particle[S,Double]]  =\n     |   collection => x => for {\n     |     cog     <- cognitive(collection, x)\n     |     soc     <- social(collection, x)\n     |     vel     <- stdVelocity(x, soc, cog, w, c1, c2)\n     |     p       <- stdPosition(x, vel)\n     |     p2      <- evalParticle(p)\n     |     p3      <- updateVelocity(p2, vel)\n     |     updated <- updatePBest(p3)\n     |   } yield updated\npso: [S](w: Double, c1: Double, c2: Double, cognitive: cilib.pso.Guide[S,Double], social: cilib.pso.Guide[S,Double])(implicit M: cilib.HasMemory[S,Double], implicit V: cilib.HasVelocity[S,Double])scalaz.NonEmptyList[cilib.pso.Particle[S,Double]] => (cilib.pso.Particle[S,Double] => cilib.Step[Double,cilib.pso.Particle[S,Double]])\nThat sure looks complex! Sure, there are a few things going on there, but it certainly is not complex - the syntax just makes the intention a little hidden due to the verbosity. The pso function defines that there are some parameters that it requires for the stdVelocity function, namely w, c1, c2. Next it requires two individual Guide instances which are the particle attactors for the velocity update equation. In the next parameter group is an implicit parameter that is constraining the types of data elements pso can work with. In this case, the pso requires that all Particle instances (which is just an alias for the type Entity[S,Position[Double]]) must have a HasMemory and HasVelocity instance available for the compiler to provide. As mentioned previously, in the section about lenses and optics, these classy lens instances prevent Entity types that do not have a memory nor a velocity present in their state parameter type. Again, we don’t know what the value of S is at the definition level, it will be made concrete when we actually use the pso function.\nEvery function within the for-comprehension is a function that yields a Step instance of the type Step[Double,Particle[S,Double]] (in this usage example). The individual Steps are then composed into a larger composition that ultimately results in the creation of a new piece of data: the particle which replaces the particle identified by the parameter x.","title":"Step"},{"location":"/design/step.html#iteration","text":"Algorithms can be executed either synchronously or asynchronously. Given an algorithm definition like the definition of pso above, it may be passed into an iteration function which converts the signature of pso function into the shape:\nList[Particle[S,A]] => RVar[A,Particle[S,A]]\nIt is important to note that the manner of execution constrains the amount of parallelism that may be applied to the iteration process. The synchronous scheme can be completely parallelized as there is no reliance on the currently building collection. The asynchronous process on the other hand builds the new collection from a combination of the current and new collections. As a result of the manner in which the asynchronous process executes, parallelism is not possible due to the shared state that is managed during the execution process.","title":"Iteration"},{"location":"/design/step_with_state.html","text":"","title":"Step with state (aka StepS)"},{"location":"/design/step_with_state.html#step-with-state-aka-steps-","text":"TODO","title":"Step with state (aka StepS)"},{"location":"/usage/index.html","text":"","title":"Usage"},{"location":"/usage/index.html#usage","text":"The following are some usage examples of how to use CIlib to define a computational intelligence algorithm, and how to execute the declared algorithm.\nAs with all algorithms, the usage is dependant on the problem goals and the follow samples are provided to give the user a taste of how the definitions are used only and do not limit the manner in which the library may be used.","title":"Usage"},{"location":"/usage/gbestpso.html","text":"","title":"Global Best PSO (GBestPSO)"},{"location":"/usage/gbestpso.html#global-best-pso-gbestpso-","text":"The GBestPSO is the canonical version of the PSO. It is popular, not only, because it is the original version of the algorithm (which is cited often within literature), but is also a simple algorithm to implement.\nAs with all algorithms modelled as a function, the type of the GBestPSO is simply defined as:\nList[Particle[S,A]] => RVar[List[Particle[S,A]]]\nwhere a collection of entities are transformed from a given set of entities to a new collection of entities, with randomness applied. This process is then repeatedly reapplied, until a stopping condition is reached.\nWe’re going to exclude the import statements simply for brevity, but the reader is encouraged to examine the example algorithm definition in the examples sub-module of the project source.","title":"Global Best PSO (GBestPSO)"},{"location":"/usage/gbestpso.html#getting-things-ready","text":"In order to define an experiment, there are a couple of things we need to get ready first. The most obvious should be that there needs to be some kind of problem, upon which we will be executing the GBestPSO.\nAs the very first step, we need to get the needed imports in scope:\nimport cilib._\nimport cilib.pso._\nimport cilib.exec._\n\nimport eu.timepit.refined.auto._\n\nimport scalaz.effect._\nimport scalaz.effect.IO.putStrLn\nimport spire.implicits._\nimport spire.math.Interval\n\nimport cilib.syntax.algorithm._\n\nimport scalaz._\nimport Scalaz._\nNext, we define the GBestPSO itself. The GBestPSO is defined to use a velocity update equation that uses the personal best of the current particle and then the collection’s current best particle to determine the new velocity vector for the current particle within the algorithm.\nLet’s define the two “particle attractors” which we need in the velocity update equation. Because these two values will attract or guide the particle in the search space, we refer to them as Guide instances:\nscala> val cognitive = Guide.pbest[Mem[Double],Double]\ncognitive: cilib.pso.Guide[cilib.Mem[Double],Double] = cilib.pso.Guide$$$Lambda$10054/1282304300@66840f24\n\nscala> val social    = Guide.gbest[Mem[Double]]\nsocial: cilib.pso.Guide[cilib.Mem[Double],Double] = cilib.pso.Guide$$$Lambda$10056/2085261069@713329b3\nAgain, we need to provide some type parameters to keep the compiler happy, but in this case we need to provide a type called Mem[Double], which is needed to track the memory of a particle and at the same time, fulfills the function constraints of the PSO algorithm itself: that the algorithm participants must cater for a HasMemory instance which exists for the Mem[Double] type.\nNow we can define the algorithm itself, providing some constants that are known to provide convergent behaviour within the PSO:\nscala> val gbestPSO = pso.Defaults.gbest(0.729844, 1.496180, 1.496180, cognitive, social)\ngbestPSO: scalaz.NonEmptyList[cilib.pso.Particle[cilib.Mem[Double],Double]] => (cilib.pso.Particle[cilib.Mem[Double],Double] => cilib.Step[Double,cilib.pso.Particle[cilib.Mem[Double],Double]]) = cilib.pso.Defaults$$$Lambda$10057/400465801@1a09fe90\n\nscala> val iter = Iteration.sync(gbestPSO)\niter: scalaz.Kleisli[[β$0$]cilib.Step[Double,β$0$],scalaz.NonEmptyList[cilib.pso.Particle[cilib.Mem[Double],Double]],scalaz.NonEmptyList[cilib.pso.Particle[cilib.Mem[Double],Double]]] = Kleisli(cilib.Iteration$$$Lambda$10058/859097852@a360511)\nNow that the algorithm is defined, we need to define an “environment” within which this algorithm will execute. The environment is simply a collection of vaues that defines the comparison and evaluator for the algorithm, such as minimizing a benchmark problem.\nLet’s define such an environment using a simple problem, borrowing the problem definition from the benchmarks sister project. We will also be minimizing this problem and defining the bounds of the problem space.\nscala> val env =\n     |   Environment(\n     |     cmp = Comparison.dominance(Min),\n     |     eval = Eval.unconstrained(cilib.benchmarks.Benchmarks.spherical[NonEmptyList, Double]).eval)\nenv: cilib.Environment[Double] = Environment(cilib.Comparison$$anon$3@349170d3,cilib.RVar$$anon$3@674466e2)\n\nscala> val bounds = Interval(-5.12,5.12)^30\nbounds: scalaz.NonEmptyList[spire.math.Interval[Double]] = NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\nHere we define a the evaluator, which is an unconstrained Eval instance, which uses the spherical function definiton from the benchmarks project. We explicitly provide the needed type parameters to keep the compiler happy, that being that the Position is a NonEmtpyList[Double]. Additionally, the cmp value defines how the optimization will be driven, which is to minimize the evaluator in this example.\nLet’s now define the entity collection that we need to given the algorithm instance. The collection requires the problem bounds and also defines how the entity instances will be initialized, once random positions are generated for the given problem space\nscala> val swarm = Position.createCollection(PSO.createParticle(x => Entity(Mem(x, x.zeroed), x)))(bounds, 20)\nswarm: cilib.RVar[scalaz.NonEmptyList[cilib.pso.Particle[cilib.Mem[Double],Double]]] = cilib.RVar$$anon$2@719068cd\nThe last requirement is to provide the RNG instance that will use used within the algorithm. We define this value and then repeatedly run the algorithm on the entity collection, stopping after 1000 iterations of the algorithm have been performed\nscala> val rng = RNG.fromTime // Seed the RNG with the current time of the computer\nrng: cilib.RNG = cilib.CMWC@6edd57a4\n\nscala> val result = Runner.repeat(1000, iter, swarm).run(env).run(rng)\nresult: (cilib.RNG, Exception \\/ scalaz.NonEmptyList[cilib.pso.Particle[cilib.Mem[Double],Double]]) = (cilib.CMWC@d5da0d7,\\/-(NonEmpty[Entity(Mem(Solution(NonEmpty[-1.0392738909671207E-8,-4.058324205556923E-8,1.4282263849323028E-8,-4.360249076427508E-8,-3.821200240183911E-9,-2.1718765206688452E-8,2.716927914294353E-7,-1.0092533053373488E-8,2.0010732124469553E-8,1.224885922671037E-8,-3.864305097189808E-9,6.447297234272222E-8,2.2174305191495573E-8,3.819785704106638E-8,2.3830300830674943E-8,-3.3297893423749706E-8,1.455768581115805E-8,-2.0056951440171007E-8,-6.744014378278866E-8,3.450559371809443E-9,1.1440339227520574E-8,-3.618990696079041E-9,-5.637832904792739E-9,9.891415863275569E-9,2.2387062406030174E-9,1.1022558392632048E-8,1.1744419827809909E-8,-1.8312885398872255E-8,-3.672398933759381...\n\nscala> result._2 match {\n     |   case -\\/(error) =>\n     |     // Not much to do. The process failed with an error\n     |     throw error\n     | \n     |   case \\/-(value) =>\n     |     value.map(x => Lenses._position.get(x))\n     | }\nres4: scalaz.NonEmptyList[cilib.Position[Double]] = NonEmpty[Solution(NonEmpty[-1.0656304940824678E-8,3.950748531518882E-8,8.337341465540018E-9,-5.6002126129598636E-8,2.397585382348853E-8,-2.7888064475985147E-8,2.714226696404566E-7,1.0784968797221434E-8,3.766643330840729E-8,-5.211722568908007E-9,-9.99176814485437E-9,7.228449817712066E-8,3.511061717106749E-8,3.584902062284332E-8,8.164351280204212E-9,7.460014841253509E-9,4.862554952971297E-9,-1.8096154668310016E-8,-6.944937009820489E-8,-6.4565196856963245E-9,7.621281562878837E-10,-1.2072525442856435E-7,-2.5853122342765917E-8,5.295064017566129E-9,-8.848352464555068E-10,3.322770169539561E-8,6.771247304430485E-8,-1.0651003151477468E-8,-3.985577055416013E-8,1.5767541217277426E-8],NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12...","title":"Getting things ready"}]}